# =============================================================================
# Flow Matching Loss Configuration
# =============================================================================
#
# This config controls loss computation for FlowMatchingHandDiT model.
# Uses component registry for modular loss computation.
# Components with weight=0 are NOT computed (saves compute).
#
# COORDINATE SPACES:
# -----------------
# - Normalized space: Data scaled to [-1, 1] via norm_min/norm_max (when use_norm_data=True)
# - World space: Original coordinates in meters
#
# LOSS COMPUTATION SPACES:
# ------------------------
# | Component                   | Space       | Notes                                        |
# |-----------------------------|-------------|-----------------------------------------------|
# | loss_fm                     | Normalized  | Flow matching MSE on velocity                 |
# | loss_tangent                | Normalized  | Tangent regularization                        |
# | reg_l1                      | Normalized  | Position MAE, consistent with flow loss       |
# | reg_chamfer                 | Normalized  | Chamfer distance                              |
# | reg_direction               | Normalized  | Cosine similarity (scale-invariant)           |
# | reg_edge_len                | Normalized  | Uses normalized edge_rest_lengths             |
# | reg_bone                    | Normalized  | Uses normalized template_xyz                  |
# | reg_collision               | Centimeter  | Via denorm_fn * scale (default: cm)           |
# | reg_fingertip_contact       | Centimeter  | Needs scene normals; signed distance on tips  |
# | reg_active_points_repulsion | Centimeter  | Needs scene normals; pushes non-fingertip pts |
#
# VALIDATION METRICS SPACES:
# --------------------------
# | Metric         | Space      | Notes                                      |
# |----------------|------------|---------------------------------------------|
# | recon_l1       | World      | Scaled by scale_factor (default: cm)       |
# | recon_chamfer  | World      | Scaled by scale_factor                     |
# | recon_direction| World      | Cosine similarity (scale-invariant)        |
# | recon_edge_len | World      | Scaled by scale_factor                     |
# | flow_loss      | Normalized | Same as training loss                      |
# | flow_loss_fm   | Normalized | Same as training loss                      |
#
# =============================================================================

# =============================================================================
# Flow Matching Loss Weights
# =============================================================================
# Main flow matching components (computed in normalized space)
weights:
  loss_fm: 1.0        # MSE between predicted and target velocity
  loss_tangent: 1.0   # Tangent regularization for rigid body constraint

# Legacy alias (backwards compatible)
lambda_tangent: 1.0

# =============================================================================
# Direct Regression Loss (for prediction_target="x" mode)
# =============================================================================
# When lambda_regression > 0, adds DeterministicRegressionLoss on x_pred vs gt_xyz.
# Requires prediction_target="x" in model config.
# Regression components in world/cm space: collision, fingertip_contact, active_points_repulsion.
# Others remain in normalized space.
lambda_regression: 0.0

# Regression loss component configuration
regression:
  recon:
    enabled: false
    l1:
      enabled: false
    chamfer:
      enabled: false
      use_pytorch3d: true
    direction:
      enabled: false
      mode: cos         # "cos" for cosine similarity
      eps: 1.0e-6
    edge_len:
      enabled: false
      eps: 1.0e-6
  
  # Component weights (weight=0 skips computation entirely)
  weights:
    l1: 0.0           # Position regression (MAE) - normalized space
    chamfer: 0.0      # Chamfer distance - normalized space
    direction: 0.0    # Edge direction alignment - normalized space
    edge_len: 0.0     # Edge length consistency - normalized space
    bone: 0.0         # Bone length vs template - normalized space (disabled)
    collision: 0.5    # Penetration penalty - WORLD space via denorm_fn (disabled)
    fingertip_contact: 0.0       # Fingertip-to-surface contact distance - WORLD space
    active_points_repulsion: 0.0 # Repulsion for non-fingertip points - WORLD space

# =============================================================================
# Collision Loss Hyperparameters
# =============================================================================
# Used when regression.weights.collision > 0
# Uses analytical point-to-capsule distance (no mesh SDF).
# Computed in CENTIMETER space (denorm * scale) for numerical stability.
# All distance parameters should be in centimeters.
collision_scale: 100.0            # Scale factor: meters -> centimeters
collision_margin: 0.1             # Minimum clearance distance (cm) = 2mm
collision_capsule_radius: 0.8     # Finger capsule radius (cm) = 8mm
collision_max_scene_points: 2048  # Max scene points for collision check
collision_chunk_size: 4096        # Points per chunk for memory efficiency

# =============================================================================
# Fingertip Contact Loss Hyperparameters
# =============================================================================
# Used when regression.weights.fingertip_contact > 0
# Constrains fingertip-to-surface distance within [min_dist, max_dist] range.
# Uses surface normals to compute signed distance.
# Computed in CENTIMETER space for numerical stability.
fingertip_contact_scale: 100.0    # Scale factor: meters -> centimeters
fingertip_contact_min_dist: 0.6   # Min allowed distance (cm) - closer triggers penalty
fingertip_contact_max_dist: 1.0   # Max allowed distance (cm) - farther triggers penalty

# =============================================================================
# Active Points Repulsion Loss Hyperparameters
# =============================================================================
# Used when regression.weights.active_points_repulsion > 0
# Repulsion loss for non-fingertip active hand points.
# Only penalizes points too close to or penetrating the object.
# Computed in CENTIMETER space for numerical stability.
active_points_repulsion_scale: 100.0    # Scale factor: meters -> centimeters
active_points_repulsion_min_dist: 0.6   # Min allowed distance (cm) - closer triggers penalty

# =============================================================================
# Sampling Frequency Configuration
# =============================================================================
# Controls how often expensive loss/metric computations are performed.
# Setting to null or 0 means compute on ALL batches (no sampling).

# Training: Number of batches per epoch to compute regression loss (reg_*)
# Useful when collision loss is expensive. null = compute on all batches.
train_num_sample_batches_for_reg_loss: 50

# Validation: Number of batches per epoch to compute recon metrics
# These require full sampling which is expensive. null = compute on all batches.
val_num_sample_batches: 10

# =============================================================================
# Validation Metrics Configuration
# =============================================================================
# Computed on sampled batches during validation.
# Recon metrics use WORLD space (denormalized) with optional scale_factor.
val_metrics:
  # Flow metrics (normalized space, same as training)
  flow:
    enabled: true
    weights:
      loss: 1.0
      loss_fm: 1.0
      loss_tangent: 0.0
      edge_len_err: 0.0
    
    # Trajectory quality metrics (computed during sampling)
    # These measure how well the model learns rectified/straight flows
    # Note: Adds one extra forward pass per sampling step when enabled
    trajectory_metrics: true   # Master switch for trajectory metrics
    trajectory_num_sample_batches: 10  # How many batches per epoch (null = same as val_num_sample_batches)
    trajectory:
      plr:                     # Path Length Ratio (arc_length / euclidean_distance)
        enabled: true          # PLR ~= 1.0 means straight trajectory
      transport_cost:          # Kinetic energy (integral of ||v||^2 dt)
        enabled: true          # Lower = more efficient transport
      velocity_consistency:    # Avg cosine similarity between adjacent velocities
        enabled: true          # Higher = more consistent velocity direction
  
  # Reconstruction quality metrics (world space)
  # Computed from: self.sample(scene_pc) vs raw_target (both in world space)
  recon:
    enabled: true
    scale_factor: 100.0   # Output in centimeters (input is meters)
    l1:
      enabled: true
      weight: 1.0
    chamfer:
      enabled: true
      weight: 1.0
      use_pytorch3d: true
    direction:
      enabled: true
      weight: 1.0
      mode: cos
      eps: 1.0e-6
    edge_len:
      enabled: true
      weight: 1.0
      eps: 1.0e-6
    # Collision metric: penetration between predicted hand and scene
    # Uses analytical point-to-capsule distance (no mesh SDF)
    # Computed in CENTIMETER space (same as reg_collision)
    collision:
      enabled: true
      scale: 100.0              # meters -> centimeters
      margin: 0.2               # Minimum clearance distance (cm) = 2mm
      capsule_radius: 0.8       # Finger capsule radius (cm) = 8mm
      max_scene_points: 2048    # Max scene points for collision check
      chunk_size: 4096          # Points per chunk for memory efficiency
